<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALLOHA - Rune Dune</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Pacifico&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: linear-gradient(135deg, #1a237e 0%, #2d3748 50%, #1a202c 100%);
            --card: rgba(26, 32, 44, 0.75);
            --text: #E2E8F0;
            --text-secondary: #A0AEC0;
            --accent: #FFD700; /* Gold */
            --accent-light: rgba(255, 215, 0, 0.1);
            --accent-gradient: linear-gradient(135deg, #FBBF24 0%, #F59E0B 100%);
            
            --cross-highlight: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(107, 33, 168, 0.25));
            --stuck-block: linear-gradient(135deg, #718096 0%, #4a5568 100%);
            
            --cell-bg: #2D3748;
            --cell-border: #4A5568;

            --glass-primary: rgba(45, 55, 72, 0.3);
            --glass-secondary: rgba(45, 55, 72, 0.18);
            --glass-border: rgba(255, 255, 255, 0.1);
            
            --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.2);
            --shadow-medium: 0 12px 40px rgba(0, 0, 0, 0.25);
            --shadow-strong: 0 20px 60px rgba(0, 0, 0, 0.3);

            --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --ease-quick: cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
        }

        #bubbles-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; overflow: hidden;
        }

        .bubble {
            position: absolute; bottom: -50px; background: rgba(255, 215, 0, 0.3); border-radius: 50%; animation: floatUp 15s infinite;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 0.7; }
            100% { transform: translateY(-120vh) scale(0.5); opacity: 0; }
        }
        
        .rounded-card {
            border-radius: 16px; background: var(--card); box-shadow: var(--shadow-soft);
        }
        
        .themed-button {
            font-weight: 600; border-radius: 16px; transition: all 0.3s var(--ease-smooth);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--shadow-soft); border: 1px solid var(--glass-border); position: relative; overflow: hidden;
        }
        
        .themed-button:active { transform: scale(0.98); }
        .themed-button:hover { transform: translateY(-2px) scale(1.02); box-shadow: var(--shadow-medium); }
        
        .glass-card {
            background: linear-gradient(135deg, var(--glass-secondary) 0%, rgba(45,55,72,0.1) 100%);
            backdrop-filter: blur(20px) saturate(180%); -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: var(--shadow-soft), 0 0 0 1px var(--glass-border), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: none !important; transition: all 0.3s var(--ease-smooth);
        }
        
        .grid-cell {
            aspect-ratio: 1; border-radius: 8px; display: flex; align-items: center; justify-content: center;
            font-size: clamp(1.2rem, 5.5vw, 2.75rem); transition: all 0.3s var(--ease-smooth);
            background: var(--cell-bg); border: 1px solid var(--cell-border);
        }
        
        .grid-cell:hover { background: #4a5568; transform: translateY(-2px); box-shadow: var(--shadow-soft); }
        
        .themed-modal {
            border-radius: 20px; background: #1a202c; color: var(--text);
            box-shadow: var(--shadow-strong); border: 1px solid var(--cell-border);
        }

        .progress-bar-container { background: rgba(0,0,0,0.3); border-radius: 9999px; }
        .progress-bar-fill { background: var(--accent-gradient); transition: width 0.3s var(--ease-smooth); }
        
        .pop-in { animation: pop-in 0.4s var(--ease-bounce); }
        @keyframes pop-in {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
        }

        .shake-animation { animation: shake 0.4s ease-in-out; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .dice-tumble { animation: dice-tumble 0.6s var(--ease-bounce); }
        @keyframes dice-tumble {
            0%   { transform: rotate(0deg) scale(1); filter: blur(0px); }
            50%  { transform: rotate(-180deg) scale(1.1); filter: blur(3px); }
            100% { transform: rotate(-360deg) scale(1); filter: blur(0px); }
        }
        
        #roll-dice-btn:not(:disabled) { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        .cross-cell {
            background: var(--cross-highlight) !important;
        }
        
        .stuck-cell {
            background: var(--stuck-block) !important; color: #1a202c; font-size: 2rem; font-weight: 600;
        }

        .modal { transition: all 0.3s var(--ease-smooth); }
        .modal.is-open { opacity: 1; visibility: visible; }
        .controls-area { min-height: 165px; display: flex; align-items: center; justify-content: center; }

        .score-update { animation: score-update 0.5s var(--ease-quick); }
        @keyframes score-update {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: var(--accent); }
            100% { transform: scale(1); }
        }

        .superpower-btn { background: transparent; border: none; box-shadow: none; color: var(--accent); font-weight: 500; border-radius: 12px; padding: 8px; transition: all 0.3s ease; cursor: pointer; }
        .superpower-btn:hover:not(:disabled) { transform: translateY(-2px); text-decoration: underline; }
        .superpower-btn:disabled { opacity: 0.5; cursor: not-allowed; text-decoration: none; }
    </style>
</head>
<body class="p-2 lg:p-4">
    <div id="bubbles-bg"></div>
    <audio id="audio-unlocker" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" preload="auto"></audio>
    
    <main id="game-container" class="w-full max-w-5xl mx-auto flex flex-col lg:flex-row gap-4 lg:gap-6 items-center lg:items-stretch pt-8 lg:pt-16">
        <div class="w-full lg:w-2/3 relative">
            <div id="effects-container" class="absolute inset-0 pointer-events-none z-10 overflow-hidden"></div>
            <div id="game-board-container" class="p-2 lg:p-6 rounded-card shadow-lg h-full">
                <div class="grid grid-cols-8 gap-1 lg:gap-3 h-full">
                    <div id="game-board" class="col-span-7 grid grid-cols-7 gap-1 lg:gap-2"></div>
                    <div id="row-scores-display" class="col-span-1 grid grid-rows-7 gap-1 lg:gap-2"></div>
                    <div id="col-scores-display" class="col-span-7 grid grid-cols-7 mt-1 lg:mt-0 gap-1 lg:gap-2"></div>
                    
                    <div class="hidden lg:flex items-center justify-center">
                        <div class="alloha-logo">
                             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 396.75 396.75"><g fill="#FFD700"><path d="M50.87 194.87V20.32h87.4v174.55h-43.7v-48.68h-43.7v48.68zm43.7-88.45v-46.06h-43.7v46.06zM294.98 267.95V93.4h87.4v174.55h-87.4zm-43.7-39.78v-94.73h-43.7v94.73zM196.27 194.87V20.32h87.4v174.55h-43.7v-39.78h-43.7zM41.88 383.95V209.4h137.9v174.55h-43.7v-68.56h-50.5v68.56zm94.21 0v-107.04h-43.7v-67.5h-43.7v174.55zM285.54 20.41h42.79v119.84h-42.79zM214.68 20.41h62.77v42.79h-62.77z"/></g></svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="w-full lg:w-1/3">
            <div id="scoring-panel" class="flex-1 flex flex-col gap-3 lg:gap-4 p-4 lg:p-6 glass-card rounded-2xl justify-between">
                <div class="flex justify-center items-center gap-3">
                    <button id="rules-btn" class="flex-1 py-2 px-4 themed-button text-sm font-semibold" style="color: var(--accent); background: var(--accent-light);">No Rules</button>
                    <button id="new-game-btn" class="flex-1 py-2 px-4 themed-button text-black font-semibold rounded-xl text-sm" style="background: var(--accent-gradient);">New Game</button>
                </div>

                <div class="relative w-full h-2.5 progress-bar-container">
                    <div id="progress-bar-fill" class="h-full rounded-full progress-bar-fill" style="width: 0%;"></div>
                </div>
                
                <div id="controls-area" class="controls-area"></div>
                
                <div class="grid grid-cols-2 gap-2 lg:gap-3 text-center">
                    <div class="glass-card rounded-xl px-3 py-2">
                        <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Total Score</h3>
                        <p id="total-score" class="text-2xl font-bold transition-all duration-300" style="color: var(--text);">0</p>
                    </div>
                    <div class="glass-card rounded-xl px-3 py-2">
                        <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">High Score</h3>
                        <p id="high-score" class="text-2xl font-bold" style="color: var(--accent);">0</p>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-2 lg:gap-3 text-center">
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Rows</h3><p id="rows-total-score" class="text-lg font-bold">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Columns</h3><p id="cols-total-score" class="text-lg font-bold">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Twinning</h3><p id="cross-total-score" class="text-lg font-bold" style="color: var(--accent);">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Grid Bonus</h3><p id="bonus-grid-score" class="text-lg font-bold" style="color: var(--accent);">0</p></div>
                </div>
                
                <div class="glass-card rounded-xl px-3 py-2">
                    <div class="text-center"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Bomb Squad Charge</h3><p id="empty-block-penalty" class="text-lg font-bold" style="color: var(--text);">0</p></div>
                </div>
            </div>
        </div>
    </main>
    
    <div id="rules-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-lg themed-modal p-6 transform scale-95 -translate-y-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold" style="font-family: 'Pacifico', cursive; color: var(--accent);">How to Play Rune Dune</h2>
                <button id="close-rules-btn" class="w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            </div>
            <div class="space-y-4 text-sm max-h-[70vh] overflow-y-auto pr-2" style="color: var(--text-secondary);">
                 <h3 class="font-bold text-lg" style="color: var(--accent);">The Objective</h3>
                 <p>Get the highest score by placing Allohas on the grid to create sequences of 3 or more identical Allohas in a line (rows or columns).</p>
                 <h3 class="font-bold text-lg" style="color: var(--accent);">Gameplay</h3>
                 <ol class="list-decimal list-inside space-y-1"><li>Choose your starting Alloha.</li><li>Click "Roll Dice" to get two new Allohas.</li><li>Place both Allohas in any two empty, adjacent (not diagonal) squares.</li></ol>
                 <h3 class="font-bold text-lg" style="color: var(--accent);">ALLOHA Powers</h3>
                 <p>Use one of three powerful, single-use abilities per game.</p>
                 <ul class="list-disc list-inside space-y-1"><li><b>Past Lives:</b> Undoes your last completed move.</li><li><b>Bomb Bae:</b> Click to activate, then click a stuck block (💣) to fill it with a random Alloha.</li><li><b>No Return:</b> Click to activate, then click any Alloha on the grid to swap it.</li></ul>
                 <h3 class="font-bold text-lg" style="color: var(--accent);">Special Blocks</h3>
                 <ul class="list-disc list-inside space-y-1">
                    <li><b>Wild Card (💎):</b> A rare treasure! This special piece acts as any Alloha and can complete any line. Appears once per game.</li>
                    <li><b>Cursed Block (☠️):</b> An immovable obstacle! This block cannot be removed by Bomb Bae or swapped with No Return. Appears once per game.</li>
                 </ul>
                 <h3 class="font-bold text-lg" style="color: var(--accent);">Scoring</h3>
                 <ul class="list-disc list-inside space-y-1"><li><b>3 in a line:</b> 3 points</li><li><b>4 in a line:</b> 8 points</li><li><b>5 in a line:</b> 10 points</li><li><b>6 in a line:</b> 14 points</li><li><b>7 in a line:</b> 20 points</li>
                 <li><b>Twinning Bonus:</b> Scores on the 4th row or 4th column are doubled!</li>
                 <li><b>Grid Bonus:</b> 2x2, 3x3, etc. grids of the same Alloha give bonus points (size * size).</li>
                 <li><b>Penalty:</b> A row or column that can no longer form a 3-symbol sequence gets a -5 penalty. A "dead" line on the twinning gets a -10 penalty.</li></ul>
            </div>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-8 transform scale-95 -translate-y-4 relative">
            <button id="close-game-over-btn" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-2" style="color: var(--accent); font-family: 'Pacifico', cursive;">Game Over!</h2>
            <p id="game-over-reason" class="text-lg mt-2 mb-4" style="color: var(--accent);"></p>
            <p id="final-score-modal" class="text-7xl font-bold my-4" style="color: var(--text);">0</p>
            <div id="score-breakdown" class="mb-6 p-4 glass-card rounded-xl text-xs">
                <div class="grid grid-cols-2 gap-2 text-left">
                    <div>Rows: <span id="final-rows-score" class="float-right font-bold">0</span></div>
                    <div>Columns: <span id="final-cols-score" class="float-right font-bold">0</span></div>
                    <div>Twinning: <span id="final-twinning-score" class="float-right font-bold">0</span></div>
                    <div>Bonus Grids: <span id="final-bonus-score" class="float-right font-bold">0</span></div>
                    <div class="col-span-2 border-t pt-2 mt-2">Bomb Squad Charge: <span id="final-penalty-score" class="float-right font-bold">0</span></div>
                </div>
            </div>
            <p>High score: <span id="high-score-modal" class="font-bold" style="color: var(--accent);">0</span></p>
            <button id="play-again-btn" class="w-full mt-6 themed-button text-black font-bold py-3 px-4 rounded-xl text-xl" style="background: var(--accent-gradient);">Play Again</button>
        </div>
    </div>
    
    <div id="exchange-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm text-center themed-modal p-6 transform scale-95 -translate-y-4">
            <h2 class="text-xl font-bold mb-4" style="color: var(--accent);">Choose a new Alloha</h2>
            <div id="exchange-options" class="grid grid-cols-3 gap-4"></div>
        </div>
    </div>

    <script>
        class GameState {
            constructor() { this.states = { PRE_GAME: 'PRE_GAME', AWAITING_ROLL: 'AWAITING_ROLL', ANIMATING_ROLL: 'ANIMATING_ROLL', AWAITING_PLACEMENT: 'AWAITING_PLACEMENT', SUPERPOWER_ACTIVE: 'SUPERPOWER_ACTIVE', PROCESSING_TURN: 'PROCESSING_TURN', GAME_OVER: 'GAME_OVER' }; this.currentState = this.states.PRE_GAME; this.validTransitions = { [this.states.PRE_GAME]: [this.states.AWAITING_ROLL], [this.states.AWAITING_ROLL]: [this.states.ANIMATING_ROLL, this.states.PRE_GAME, this.states.SUPERPOWER_ACTIVE, this.states.AWAITING_PLACEMENT], [this.states.ANIMATING_ROLL]: [this.states.AWAITING_PLACEMENT], [this.states.AWAITING_PLACEMENT]: [this.states.PROCESSING_TURN, this.states.AWAITING_ROLL, this.states.SUPERPOWER_ACTIVE], [this.states.SUPERPOWER_ACTIVE]: [this.states.AWAITING_ROLL, this.states.AWAITING_PLACEMENT, this.states.PROCESSING_TURN], [this.states.PROCESSING_TURN]: [this.states.AWAITING_ROLL, this.states.GAME_OVER], [this.states.GAME_OVER]: [this.states.PRE_GAME] }; }
            setState(newState) { if (!this.validTransitions[this.currentState]?.includes(newState)) { console.warn(`Invalid state transition from ${this.currentState} to ${newState}`); return false; } this.currentState = newState; return true; }
            is(state) { return this.currentState === state; }
        }
        
        class Game {
            constructor() {
                this.RUNE_SYMBOLS = { 'Mystic Ball': '🔮', 'Nazar': '🧿', 'Moon': '🌙', 'Vortex': '🌀', 'Genie': '🧞', 'Dragon Tile': '🀄' };
                this.SPECIAL_SYMBOLS = { 'WILD': '💎', 'CURSED': '☠️' };
                this.SYMBOLS = Object.values(this.RUNE_SYMBOLS);
                this.SCORING_RULES = { 7: 20, 6: 14, 5: 10, 4: 8, 3: 3 };
                this.GRID_SIZE = 7; this.MAX_TURNS = 24; this.CROSS_MULTIPLIER = 2; this.LINE_DEATH_PENALTY = -5; this.CROSS_DEATH_PENALTY = -10; this.STUCK_BLOCK_PENALTY = -1; this.MIN_SEQUENCE_LENGTH = 3;
                
                this.gameStateManager = null; this.gridData = null; this.currentRoll = null; this.firstPlacementCell = null; this.turnCount = null; this.highScore = null; this.stuckBlocks = null;
                this.lastGameState = null; this.hasSuperpowerBeenUsed = null; this.activeSuperpower = null; this.cellToExchange = null; this.currentTotalScore = null;
                this.cursedBlockTurn = null; this.wildcardTurn = null;
                this.gridCells = [];
                this.DOMElements = this.getDOMElements();

                this.init();
            }
            
            getDOMElements() {
                const elementIds = ['game-board','controls-area','row-scores-display','col-scores-display','total-score','high-score','rows-total-score','cols-total-score','cross-total-score','bonus-grid-score','empty-block-penalty','rules-btn','rules-modal','close-rules-btn','game-over-modal','game-over-reason','close-game-over-btn','final-score-modal','high-score-modal','play-again-btn','score-breakdown','final-rows-score','final-cols-score','final-twinning-score','final-bonus-score','final-penalty-score','exchange-modal','exchange-options','progress-bar-fill','new-game-btn','game-board-container','scoring-panel','bubbles-bg','effects-container'];
                const elements = {};
                elementIds.forEach(id => { elements[id] = document.getElementById(id); });
                return elements;
            }

            init() {
                this.gameStateManager = new GameState();
                this.gridData = Array(this.GRID_SIZE).fill(null).map(() => Array(this.GRID_SIZE).fill(null));
                this.currentRoll = []; this.firstPlacementCell = null; this.turnCount = 0; this.stuckBlocks = new Set();
                this.highScore = parseInt(localStorage.getItem('runeDuneHighScore')) || 0;
                this.hasSuperpowerBeenUsed = false; this.activeSuperpower = null; this.lastGameState = null; this.cellToExchange = null; this.currentTotalScore = 0;
                this.cursedBlockTurn = Math.floor(Math.random() * 8) + 5;
                this.wildcardTurn = Math.floor(Math.random() * 8) + 15;
                if (this.wildcardTurn === this.cursedBlockTurn) this.wildcardTurn++;

                this.DOMElements['high-score'].textContent = this.highScore;
                ['game-over-modal', 'exchange-modal', 'rules-modal'].forEach(id => this.DOMElements[id].classList.remove('is-open'));
                this.DOMElements['empty-block-penalty'].textContent = '0';
                this.renderGrid(); this.renderScorePlaceholders(); this.renderControls(); this.updateAllScores();
                this.updateProgressBar();
                this.syncPanelHeights();
                this.createAmbientBubbles();
                this.setupEventListeners();
            }
            
            createAmbientBubbles() {
                const bubbleContainer = this.DOMElements['bubbles-bg'];
                if (!bubbleContainer) return;
                bubbleContainer.innerHTML = '';
                for (let i = 0; i < 20; i++) {
                    const bubble = document.createElement('span');
                    bubble.className = 'bubble';
                    const size = Math.random() * 20 + 5 + 'px';
                    bubble.style.width = size;
                    bubble.style.height = size;
                    bubble.style.left = Math.random() * 100 + '%';
                    bubble.style.animationDuration = Math.random() * 8 + 10 + 's';
                    bubble.style.animationDelay = Math.random() * 5 + 's';
                    bubbleContainer.appendChild(bubble);
                }
            }

            triggerScoreBubbles(count) {
                const effectsContainer = this.DOMElements['effects-container'];
                if (!effectsContainer) return;
                for(let i = 0; i < count; i++) {
                    const bubble = document.createElement('span');
                    bubble.className = 'bubble';
                    const size = Math.random() * 25 + 10 + 'px';
                    bubble.style.width = size;
                    bubble.style.height = size;
                    bubble.style.left = Math.random() * 100 + '%';
                    const duration = Math.random() * 4 + 2;
                    bubble.style.animationDuration = duration + 's';
                    effectsContainer.appendChild(bubble);
                    setTimeout(() => bubble.remove(), duration * 1000);
                }
            }

            calculateLineScore(line, type, lineIndex) {
                let totalScore = 0;
                let temp = [...line];
                let foundAnySequence = false;
                let foundSequenceThisPass = true;
                while (foundSequenceThisPass) {
                    foundSequenceThisPass = false;
                    for (let len = this.GRID_SIZE; len >= this.MIN_SEQUENCE_LENGTH; len--) {
                        for (let i = 0; i <= temp.length - len; i++) {
                            const slice = temp.slice(i, i + len);
                            if (slice.includes(null) || slice.includes(this.SPECIAL_SYMBOLS.CURSED)) continue;
                            if (this.isValidSequence(slice)) {
                                totalScore += this.SCORING_RULES[len];
                                foundAnySequence = true;
                                foundSequenceThisPass = true;
                                temp.fill(null, i, i + len);
                                break;
                            }
                        }
                        if (foundSequenceThisPass) break;
                    }
                }
                if (foundAnySequence) return { score: totalScore };
                if (this.isLineDead(line, type, lineIndex)) return { score: this.LINE_DEATH_PENALTY };
                return { score: 0 };
            }
            
            isValidSequence(slice) {
                if (slice.every(s => s === this.SPECIAL_SYMBOLS.WILD)) return true;
                const regularSymbols = slice.filter(s => s !== this.SPECIAL_SYMBOLS.WILD);
                if (regularSymbols.length === 0) return true;
                if (new Set(regularSymbols).size === 1) return true;
                return false;
            }
            
            isLineDead(line, type, lineIndex) {
                for (let i = 0; i <= line.length - this.MIN_SEQUENCE_LENGTH; i++) {
                    const window = line.slice(i, i + this.MIN_SEQUENCE_LENGTH);
                    let winnable = true;
                    if (window.includes(this.SPECIAL_SYMBOLS.CURSED)) { winnable = false; continue; }
                    for (let j = 0; j < this.MIN_SEQUENCE_LENGTH; j++) {
                        let r, c;
                        if (type === 'row') { r = lineIndex; c = i + j; } else { r = i + j; c = lineIndex; }
                        if (this.stuckBlocks.has(`${r},${c}`)) { winnable = false; break; }
                    }
                    if (!winnable) continue;
                    const nonNullSymbols = window.filter(cell => cell !== null);
                    if (nonNullSymbols.length > 0) {
                        const regularSymbols = nonNullSymbols.filter(s => s !== this.SPECIAL_SYMBOLS.WILD);
                        if (regularSymbols.length > 0 && new Set(regularSymbols).size <= 1) { winnable = true; } 
                        else if (regularSymbols.length === 0) { winnable = true; } 
                        else { winnable = false; }
                    }
                    if (winnable) return false;
                }
                return true;
            }

            calculateBonusGrids(gridData) {
                let points = 0;
                for (let size = this.GRID_SIZE; size >= 2; size--) {
                    for (let r = 0; r <= this.GRID_SIZE - size; r++) {
                        for (let c = 0; c <= this.GRID_SIZE - size; c++) {
                            const firstSymbol = gridData[r][c];
                            if (!firstSymbol || firstSymbol === this.SPECIAL_SYMBOLS.CURSED) continue;
                            let targetSymbol = firstSymbol;
                            if (targetSymbol === this.SPECIAL_SYMBOLS.WILD) {
                                let foundSymbol = false;
                                for (let i = r; i < r + size; i++) {
                                    for (let j = c; j < c + size; j++) {
                                        const current = gridData[i][j];
                                        if (current && current !== this.SPECIAL_SYMBOLS.WILD && current !== this.SPECIAL_SYMBOLS.CURSED) {
                                            targetSymbol = current; foundSymbol = true; break;
                                        }
                                    }
                                    if (foundSymbol) break;
                                }
                            }
                            let isGrid = true;
                            for (let i = r; i < r + size; i++) {
                                for (let j = c; j < c + size; j++) {
                                    const currentSymbol = gridData[i][j];
                                    if (!currentSymbol || currentSymbol === this.SPECIAL_SYMBOLS.CURSED) { isGrid = false; break; }
                                    if (targetSymbol === this.SPECIAL_SYMBOLS.WILD) {
                                        if (currentSymbol !== this.SPECIAL_SYMBOLS.WILD) { isGrid = false; break; }
                                    } else {
                                        if (currentSymbol !== targetSymbol && currentSymbol !== this.SPECIAL_SYMBOLS.WILD) { isGrid = false; break; }
                                    }
                                }
                                if (!isGrid) break;
                            }
                            if (isGrid) { points += size * size; }
                        }
                    }
                }
                return points;
            }

            createCellElement(r, c) { const cell = document.createElement('div'); cell.dataset.row = r; cell.dataset.col = c; cell.className = this.getCellClasses(r, c); return cell; }
            getCellClasses(r, c) { let classes = 'grid-cell'; if (r === 3 || c === 3) classes += ' cross-cell'; if (this.stuckBlocks.has(`${r},${c}`)) classes += ' stuck-cell'; return classes; }
            updateCell(cell, r, c) { const symbol = this.gridData[r][c]; cell.className = this.getCellClasses(r, c); if (symbol) { cell.textContent = symbol; cell.classList.add('pop-in'); } else if (this.stuckBlocks.has(`${r},${c}`)) { cell.textContent = '💣'; } else { cell.textContent = ''; } }
            addCellEventListeners(cell) { cell.addEventListener('click', (e) => this.handleCellClick(e)); }

            syncPanelHeights() {
                setTimeout(() => {
                    if (window.innerWidth < 1024) { this.DOMElements['scoring-panel'].style.height = 'auto'; return; }
                    const boardHeight = this.DOMElements['game-board-container']?.getBoundingClientRect().height;
                    if (boardHeight && this.DOMElements['scoring-panel']) { this.DOMElements['scoring-panel'].style.height = `${boardHeight}px`; }
                }, 50);
            }
            updateProgressBar() { if (!this.DOMElements['progress-bar-fill']) return; const percentage = (this.turnCount / this.MAX_TURNS) * 100; this.DOMElements['progress-bar-fill'].style.width = `${percentage}%`; }

            renderGrid() {
                const fragment = document.createDocumentFragment(); this.DOMElements['game-board'].innerHTML = ''; this.gridCells = [];
                for (let r = 0; r < this.GRID_SIZE; r++) {
                    const row = [];
                    for (let c = 0; c < this.GRID_SIZE; c++) {
                        const cell = this.createCellElement(r, c); this.updateCell(cell, r, c); this.addCellEventListeners(cell);
                        fragment.appendChild(cell); row.push(cell);
                    }
                    this.gridCells.push(row);
                }
                this.DOMElements['game-board'].appendChild(fragment);
            }

            updateFullGrid() { for (let r = 0; r < this.GRID_SIZE; r++) for (let c = 0; c < this.GRID_SIZE; c++) this.updateGridCell(r, c); }
            updateGridCell(r, c) { if (this.gridCells[r]?.[c]) this.updateCell(this.gridCells[r][c], r, c); }

            renderScorePlaceholders() {
                this.DOMElements['row-scores-display'].innerHTML = ''; this.DOMElements['col-scores-display'].innerHTML = '';
                for (let i = 0; i < this.GRID_SIZE; i++) {
                    const rowScore = document.createElement('div'); rowScore.id = `row-score-${i}`; rowScore.className = 'grid-cell text-gray-400 text-lg lg:text-2xl'; rowScore.textContent = '0'; this.DOMElements['row-scores-display'].appendChild(rowScore);
                    const colScore = document.createElement('div'); colScore.id = `col-score-${i}`; colScore.className = 'grid-cell text-gray-400 text-lg lg:text-2xl'; colScore.textContent = '0'; this.DOMElements['col-scores-display'].appendChild(colScore);
                }
            }

            renderControls() {
                this.DOMElements['controls-area'].innerHTML = '';
                if (this.gameStateManager.is('PRE_GAME')) {
                    const container = document.createElement('div'); container.className = 'w-full flex flex-col items-center';
                    container.innerHTML = `<h2 class="text-base lg:text-lg font-semibold text-center mb-4 uppercase tracking-wider" style="color: var(--accent);">CHOOSE YOUR ALLOHA</h2>`;
                    const selector = document.createElement('div'); selector.className = 'grid grid-cols-3 gap-2 lg:gap-4';
                    this.SYMBOLS.forEach((symbol) => {
                        const btn = document.createElement('button');
                        btn.className = `symbol-selector-btn aspect-square rounded-xl text-4xl lg:text-5xl hover:bg-gray-700 flex items-center justify-center`;
                        btn.textContent = symbol;
                        btn.onclick = () => this.handleSymbolSelect(symbol);
                        selector.appendChild(btn);
                    });
                    container.appendChild(selector);
                    this.DOMElements['controls-area'].appendChild(container);
                } else {
                    const wrapper = document.createElement('div'); wrapper.className = 'w-full flex flex-col justify-center gap-3 lg:gap-4';
                    wrapper.innerHTML = `<div class="flex justify-center items-center gap-2 lg:gap-4"><button id="roll-dice-btn" class="w-14 h-14 lg:w-16 lg:h-16 text-4xl lg:text-5xl flex items-center justify-center">🎲</button><div id="dice-1" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card flex items-center justify-center text-3xl lg:text-4xl">?</div><div id="dice-2" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card flex items-center justify-center text-3xl lg:text-4xl">?</div></div><div id="alloha-power-panel" class="glass-card rounded-xl px-3 py-4 text-center"><h2 class="text-sm font-semibold uppercase tracking-wider mb-3 flex items-center justify-center gap-2" style="color: var(--text-secondary);"><span style="font-size: 16px;">🪄</span>ALLOHA Powers</h2><div class="grid grid-cols-3 gap-2 text-xs"><button id="past-lives-btn" class="superpower-btn"><div>Past</div><div>Lives</div></button><button id="bomb-bae-btn" class="superpower-btn"><div>Bomb</div><div>Bae</div></button><button id="no-return-btn" class="superpower-btn"><div>No</div><div>Return</div></button></div></div>`;
                    wrapper.querySelector('#roll-dice-btn').onclick = this.handleRollDice.bind(this);
                    this.DOMElements['controls-area'].appendChild(wrapper);
                }
            }

            updateControlsState() {
                if (this.gameStateManager.is('PRE_GAME')) return;
                const rollBtn = document.getElementById('roll-dice-btn');
                if (rollBtn) rollBtn.disabled = !this.gameStateManager.is('AWAITING_ROLL');
                const dice1 = document.getElementById('dice-1'), dice2 = document.getElementById('dice-2');
                if (this.gameStateManager.is('AWAITING_PLACEMENT') && this.currentRoll.length === 2) {
                    dice1.textContent = this.currentRoll[0]; dice2.textContent = this.currentRoll[1];
                } else {
                    dice1.textContent = '?'; dice2.textContent = '?';
                }
            }

            handleSymbolSelect(symbol) { this.gameStateManager.setState('AWAITING_ROLL'); this.gridData[0][0] = symbol; this.updateFullGrid(); this.renderControls(); this.updateControlsState(); }
            
            handleRollDice() {
                if (!this.gameStateManager.is('AWAITING_ROLL')) return;
                this.currentRoll = [this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)], this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)]];
                this.gameStateManager.setState('ANIMATING_ROLL'); this.updateControlsState();
                const d1 = document.getElementById('dice-1'), d2 = document.getElementById('dice-2');
                d1.classList.add('dice-tumble'); d2.classList.add('dice-tumble');
                setTimeout(() => {
                    d1.classList.remove('dice-tumble'); d2.classList.remove('dice-tumble');
                    this.gameStateManager.setState('AWAITING_PLACEMENT'); this.updateControlsState();
                }, 600);
            }

            handleCellClick(e) {
                const cell = e.target.closest('[data-row]'); if (!cell) return;
                const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col);
                if (this.activeSuperpower) { return; }
                if (!this.gameStateManager.is('AWAITING_PLACEMENT')) return;
                if (this.firstPlacementCell) { this.handleSecondPlacement(r, c, cell); } else { this.handleFirstPlacement(r, c); }
            }

            handleFirstPlacement(r, c) { if (!this.gridData[r][c]) { this.gridData[r][c] = this.currentRoll[0]; this.firstPlacementCell = { r, c }; this.updateGridCell(r, c); } }
            
            handleSecondPlacement(r, c, cell) {
                const { r: pR, c: pC } = this.firstPlacementCell;
                if (pR === r && pC === c) { this.gridData[r][c] = null; this.firstPlacementCell = null; this.updateGridCell(r, c); return; }
                if ((Math.abs(pR - r) + Math.abs(pC - c) === 1) && !this.gridData[r][c]) { this.completeMove(r, c); } 
                else { cell.classList.add('shake-animation'); setTimeout(() => cell.classList.remove('shake-animation'), 400); }
            }
            
            completeMove(r, c) {
                this.gameStateManager.setState('PROCESSING_TURN'); this.gridData[r][c] = this.currentRoll[1];
                this.firstPlacementCell = null; this.turnCount++; this.updateGridCell(r, c);
                setTimeout(() => this.processTurnEnd(), 300);
            }
            
            processTurnEnd() {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.detectStuckBlocks(); 
                this.updateAllScores();
                this.updateProgressBar();
                if (this.turnCount >= this.MAX_TURNS) { this.endGame("Grid is full!"); return; }
                if (!this.hasValidMoves()) { this.endGame("No valid moves!"); return; }
                this.gameStateManager.setState('AWAITING_ROLL'); 
                this.updateControlsState();
            }

            endGame(reason = "") {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.gameStateManager.setState('GAME_OVER');
                this.updateAllScores();
                const finalScore = this.currentTotalScore;
                if (finalScore > this.highScore) { this.highScore = finalScore; localStorage.setItem('runeDuneHighScore', this.highScore); }
                const { rowScores, colScores, deadLinePenalty, crossScore } = this.calculateAllLineScores();
                this.DOMElements['game-over-reason'].textContent = reason;
                this.DOMElements['final-score-modal'].textContent = finalScore;
                this.DOMElements['high-score-modal'].textContent = this.highScore;
                this.DOMElements['final-rows-score'].textContent = rowScores.total;
                this.DOMElements['final-cols-score'].textContent = colScores.total;
                this.DOMElements['final-twinning-score'].textContent = crossScore;
                this.DOMElements['final-bonus-score'].textContent = this.calculateBonusGrids(this.gridData);
                this.DOMElements['final-penalty-score'].textContent = -this.stuckBlocks.size;
                setTimeout(() => this.DOMElements['game-over-modal'].classList.add('is-open'), 500);
            }
            
            calculateAllLineScores() {
                let rowScores = { total: 0, individual: [] };
                let colScores = { total: 0, individual: [] };
                for (let i = 0; i < this.GRID_SIZE; i++) {
                    const row = this.gridData[i];
                    const col = this.gridData.map(r => r[i]);
                    const { score: rowScore } = this.calculateLineScore(row, 'row', i);
                    const { score: colScore } = this.calculateLineScore(col, 'col', i);
                    rowScores.total += rowScore;
                    colScores.total += colScore;
                    rowScores.individual.push(rowScore);
                    colScores.individual.push(colScore);
                }
                const crossScore = this.calculateCrossScore();
                return { rowScores, colScores, crossScore };
            }

            updateAllScores() {
                const { rowScores, colScores, crossScore } = this.calculateAllLineScores();
                const bonusGridScore = this.calculateBonusGrids(this.gridData);
                const stuckBlockPenalty = -this.stuckBlocks.size;
                this.currentTotalScore = rowScores.total + colScores.total + crossScore + bonusGridScore + stuckBlockPenalty;
                this.animateScoreUpdate(this.DOMElements['total-score'], this.currentTotalScore);
                this.animateScoreUpdate(this.DOMElements['rows-total-score'], rowScores.total);
                this.animateScoreUpdate(this.DOMElements['cols-total-score'], colScores.total);
                this.animateScoreUpdate(this.DOMElements['cross-total-score'], crossScore);
                this.animateScoreUpdate(this.DOMElements['bonus-grid-score'], bonusGridScore);
                this.animateScoreUpdate(this.DOMElements['empty-block-penalty'], stuckBlockPenalty);
                this.updateIndividualScores(rowScores.individual, colScores.individual);
            }
            
            calculateCrossScore() {
                let bonusScore = 0;
                const crossRow = this.gridData[3];
                const crossCol = this.gridData.map(row => row[3]);
                const rowResult = this.calculateLineScore(crossRow, 'row', 3);
                const colResult = this.calculateLineScore(crossCol, 'col', 3);
                if (rowResult.score > 0) { bonusScore += rowResult.score; } 
                else if (rowResult.score === this.LINE_DEATH_PENALTY) { bonusScore += this.CROSS_DEATH_PENALTY - this.LINE_DEATH_PENALTY; }
                if (colResult.score > 0) { bonusScore += colResult.score; } 
                else if (colResult.score === this.LINE_DEATH_PENALTY) { bonusScore += this.CROSS_DEATH_PENALTY - this.LINE_DEATH_PENALTY; }
                return bonusScore;
            }

            detectStuckBlocks() {
                this.stuckBlocks.clear();
                for (let r = 0; r < this.GRID_SIZE; r++) {
                    for (let c = 0; c < this.GRID_SIZE; c++) {
                        if (!this.gridData[r][c]) {
                            const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                            const isStuck = neighbors.every(([dr, dc]) => {
                                const nr = r + dr, nc = c + dc;
                                return nr < 0 || nr >= this.GRID_SIZE || nc < 0 || nc >= this.GRID_SIZE || this.gridData[nr][nc];
                            });
                            if (isStuck) this.stuckBlocks.add(`${r},${c}`);
                        }
                    }
                }
            }

            hasValidMoves() {
                for (let r = 0; r < this.GRID_SIZE; r++) {
                    for (let c = 0; c < this.GRID_SIZE; c++) {
                        if (!this.gridData[r][c]) {
                            const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                            for (const [dr, dc] of neighbors) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < this.GRID_SIZE && nc >= 0 && nc < this.GRID_SIZE && !this.gridData[nr][nc]) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            updateIndividualScores(rS, cS) {
                rS.forEach((s, i) => { const el = document.getElementById(`row-score-${i}`); if (el) el.textContent = s; });
                cS.forEach((s, i) => { const el = document.getElementById(`col-score-${i}`); if(el) el.textContent = s; });
            }
            
            animateScoreUpdate(el, val) {
                const startVal = parseInt(el.textContent) || 0; if (startVal === val) return;
                const duration = 500, stepTime = 20, totalSteps = duration / stepTime;
                const increment = (val - startVal) / totalSteps; let currentVal = startVal, step = 0;
                const timer = setInterval(() => {
                    step++; if (step >= totalSteps) { clearInterval(timer); el.textContent = val; return; }
                    currentVal += increment; el.textContent = Math.round(currentVal);
                }, stepTime);
            }
            
            setupEventListeners() {
                this.DOMElements['new-game-btn'].addEventListener('click', () => this.init());
                this.DOMElements['rules-btn'].addEventListener('click', () => this.DOMElements['rules-modal'].classList.add('is-open'));
                this.DOMElements['close-rules-btn'].addEventListener('click', () => this.DOMElements['rules-modal'].classList.remove('is-open'));
                this.DOMElements['close-game-over-btn'].addEventListener('click', () => this.DOMElements['game-over-modal'].classList.remove('is-open'));
                this.DOMElements['play-again-btn'].addEventListener('click', () => { this.DOMElements['game-over-modal'].classList.remove('is-open'); setTimeout(() => this.init(), 200); });
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => { new Game(); });
    </script>
</body>
</html>
